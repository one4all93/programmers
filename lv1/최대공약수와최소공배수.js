// 문제 설명
// 두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 
// 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 
// 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.

// 제한 사항
// 두 수는 1이상 1000000이하의 자연수입니다.
// 입출력 예
// n	m	return
// 3	12	[3, 12]
// 2	5	[1, 10]
// 입출력 예 설명
// 입출력 예 #1
// 위의 설명과 같습니다.

// 입출력 예 #2
// 자연수 2와 5의 최대공약수는 1, 최소공배수는 10이므로 [1, 10]을 리턴해야 합니다.

// 최대공약수는 두 수를 나눌 수 있는 가장 큰 수
// 최소공배수는 두 수가 공통으로 가지는 배수 중 가장 작은 수

// 유클리드 호제법(Euclidean Algorithm)
// 두 양의 정수 또는 다항식의 **최대공약수(GCD, Greatest Common Divisor)**를 구하는 효율적인 알고리즘입니다. 
// 이 방법은 큰 수를 작은 수로 나누고, 그 나머지가 0이 될 때까지 이 과정을 반복하는 원리를 사용하며, 나머지가 0이 된 직전의 수가 바로 최대공약수가 됩니다. 
    // 나눗셈: 두 수 A와 B (A ≥ B)가 있다고 할 때, A를 B로 나눕니다. A = B * Q + R 이고, 여기서 R은 나머지입니다. 
    // 종료 조건 확인: 만약 나머지 R이 0이라면, B가 최대공약수(GCD)가 됩니다. 
    // 반복: R이 0이 아니라면, 원래의 B를 새로운 A로, 나머지를 새로운 B로 하여 다시 나눗셈을 수행합니다. 이 과정을 반복합니다. 

let n = 3;
let m = 12;
n = 2;
m= 5;

solution(n, m);

function solution(n, m) {
    var answer = [];

    // a :: 두수의 최소공배수를 구하기 위해 미리 곱한 값 계산
    let a = m*n;
    // 유클리드를 사용해서 나머지가 0이 될때까지 반복계산해서 값을 넣어주기 위해 값 세팅
    let b = 0;

    // n(나누는값)이 0이 될때까지 나누기
    while(n !== 0){
        // 나누어지는 값 미리 세팅
        let temp = n;
        // 나머지값 세팅
        n = m%n;
        // 나누어질 값 반복돌려야하니까 m에 세팅
        m = temp;

        b = m;
    }

    // 나눈값 0이면 m:최대공약수
    console.log(a,b,a/b);

    answer = [b,a/b];

    return answer;
}