Sieve of Eratosthenes(에라토스테네스의 체)

고대 그리스의 수학자 에라토스테네스가 만들어 낸 소수를 찾는 방법.
이 방법은 마치 체로 치듯이 수를 걸러낸다고 하여 '에라토스테네스의 체'라고 불린다.

임의의 자연수 n에 대해 그 이하의 소수를 모두 찾는, 가장 간단하고 빠른 방법이다.

** 1~144까지의 숫자 중 소수를 찾는다 하자.

1) 일단 소수도, 합성수도 아닌 유일한 자연수 1을 제거한다.
2) 2를 제외한* 2의 배수를 제거한다.(2를 제외하는건 2는 1과 2자신만을 약수로 가진다 -> 소수)
3) 3을 제와한 3의 배수를 제거한다. (2와 동일)
4) 그 다음으로 가장 작은 소수 5를 제외한 5의 배수를 제거한다.(4를 제외한이유는 2의 배수를 제거하면서 이미 지워짐)
5) ...7...11...13...17...이런식으로 소수들을 찾아나감
.
.
.
결론) 이렇게 소수를 기준으로 배수를 지워나가다보니 
      주어진n의 제곱근을 구해서 1~제곱근까지의 소수를 찾는 공식을 찾음 == 소수를 찾는 문제에서는 제곱근을 구해서 n을 나누는 공식을 바로 사용하자**

*** 왜 제곱근인가?
- 어떤 합성수 m = a × b가 있다고 하자
- 만약 a > √n 이면 b < √n
- 즉, 작은 수로 이미 배수를 지우면서 m도 자동으로 제거됨
- 그래서 굳이 √n보다 큰 수까지 소수로 나누어볼 필요 없음

function eratosthenes(n) {
    // 1. true로 채워진 배열 생성 (일단 모두 소수라고 가정)
    let isPrime = Array(n + 1).fill(true);
    isPrime[0] = false;
    isPrime[1] = false;

    // 2. 2부터 √n까지 확인
    for (let i = 2; i <= Math.sqrt(n); i++) {   ==> 합성수를 판별하기 위한 최소한의 나눗셈 구간****(모든약수가 제곱근 이하에 반드시 존재한다는 성질을 이용)
        if (isPrime[i]) {
            // 3. i의 배수 제거 (i*i부터 시작)
            for (let j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }

    // 4. 남은 true 인덱스가 소수
    const primes = [];
    for (let i = 2; i <= n; i++) {
        if (isPrime[i]) primes.push(i);
    }

    return primes;
}

console.log(eratosthenes(30)); // [2,3,5,7,11,13,17,19,23,29]



function check(m){
    if(m<2) return true;    // 소수니까 1은 제외

    for(let i=2; i<=Math.sqrt(m); i++){ // 위에서 1을 제외했으니 2부터 시작
        if(m%i == 0) return false;
    }
    answer++;
}